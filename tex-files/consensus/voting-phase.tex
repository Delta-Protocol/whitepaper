The third phase of the ledger cycle is the Voting Phase within which a producer $p$ from the $C$ candidates it has received decides on what it believes should be the global ledger state update i.e. the update that should be applied to the ledger for that cycle.



\begin{enumerate}
\item $p$ verifies that the same first hash value $u^{maj}$ is embedded in a majority of producer candidates.
\item $p$ is required at this point to have created the majority ledger update. As only with this partial update can they participate effectively. Therefore their $u == u^{maj}$

\end{enumerate}

If each producer collects the first hash value generated by every producer, any two producers would build the same list of identifiers $\mathcal{L}(prod)$. However even in highly efficient distributed network it is unlikely that all producers will retrieve all information. Therefore it must be assumed that the list of identifiers held by $p$ is incomplete, $p$ however must ensure that they hold enough information to confidently issue a vote on the update to the ledger. The identifier of a producer is appended to the hash they distribute because:

\begin{itemize}
\item To verify that $p$ is a producer node and that they in fact were one of the winners of the random draw described in \ref{insert ref}.
\item To evaluate and track the quality of the work performed by $p$.
\item To ensure that the correct producers withing $P$ are rewarded for their work maintaining the ledger. \\

\end{itemize}

New transaction entries (compensation entries) are created using the list's  $\mathcal{L}(prod)$ produced by the producers $p$. This allows reward and fees to be paid to the correct users. These new transaction entries will be appended to the final ledger state update for that cycle. Therefore a complete ledger state update should consist of:

\begin{itemize}
\item The list of transaction entries integrated into the new ledger state all $E$ lists.
\item The transaction signatures from $T$ held in $d$.
\item Compensation entries rewarding the producers from $\mathcal{L}(prod)$.

\end{itemize}

The voting process thereby must confirm the correct list of identifiers involved in producing the correct ledger state updates. The final list for  $\mathcal{L}(prod)$ is generated by merging the producers lists together. In order for a producer $p$ to have their $Id$ added to the final  $\mathcal{L}(prod)$ the must appear in at least 50\% of the  $\mathcal{L}(prod)$ lists distributed by $P$. This ensures that no producer can just append their own $Id$ to their update whether that update was correct or not and gain a reward for it.  \\

As explained below the final list $\mathcal{L}_n(prod)$ is obtained by merging the partial lists included in the producers' candidate. A producer $P_j$ could have produced a first hash value $h_{\Delta j}$ different to $h^{maj}_{\Delta j}$ yet added his identifier to $\mathcal{L}_j(prod)$ when building its candidate $c_j$ in the attempt to collect some token reward. In such scenario $Id_j$ would be an element of the list included in $c_j$ (or any other producer node controlled by $P_j$), but it wouldn't be included in any other list $\{\mathcal{L}_k(prod)\} \forall~k \in P/j$. To prevent such malicious behavior, a rule imposes that $P_j$ only appends to the final list $\mathcal{L}_n(prod)$ the identifier of a producer included in the list $\mathcal{L}_k(prod)$ of a candidate $c_k$ satisfying $h^{maj}_{\Delta k} = h^{maj}$ if and only if that identifier is included in at least $P/2$ lists $\{\mathcal{L}_{k}(prod)\}_{k=1,..,V_j}$ associated to a candidate $c_{k}$ satisfying $h^{maj}_{\Delta k} = h^{maj}$. Only a producer controlling half or more of the producer nodes would succeed in including its identifier into the final list $\mathcal{L}_n(prod)$.\\

Although this eliminates the risk of unethical behavior from the producer, this also means that there would be little incentive for a producer to broadcast its vote if its identifier was not included in $\mathcal{L}_n(prod)$. However, the probability that a producer compiles the correct final list $\mathcal{L}_n(prod)$ strongly depends on the number of votes collected. The more votes collected by a producer, the greater the probability that said producer will compile the complete final list. Although a producer may not have produced the correct partial ledger state update, participating in the voting process is, therefore, an important contribution to the overall consensus protocol and should entitle the producer nodes to some reward. To that end a producer $P_j$ can use the identifier of other producers included in their vote and create a second list $\mathcal{L}_j(vote)$ to account for their participation in the voting process. \\

$p$ follows a series of steps:

\begin{enumerate}
\item $p$ generates a list $\mathcal{L}(vote)$ it then appends the $Id$ of any other $p$ that has forwarded a $C$ candidate that satisfies $u == u^{maj}$.
\item $p$ creates the combined list for $\mathcal{L}(prod)$ of any $p$ from $P$ that appears in $P/2$ lists.
\item Then $p$ creates a list $L_{CE}$. This contains the contribution entries. This is for any user that is included in the combined $\mathcal{L}(prod)$. Each of these producers contained within this list will receive $x$ tokens. If it is considered that $X$ is the total number of tokens that are injected into the network at each cycle for the pool of $P$ producers. The amount of entries into $L_{CE}$ will be less than or equal to $P$. $R$ is to be considered the total amount of reward that is to be split among all the producers that found the correct ledger update $R = f_{prod}X + v$ where $f_prod$ is the fraction of the injected tokens that are given to users found in the combined $L_{prod}$. While $(1-f_{prod})X$ is the value that is distributed to other nodes that have performed work.
\item Producer $p$ can then create the candidate ledger state update for this cycle. This includes the reward allocations for producers according to their contributions. This ledger state update $LSU$ can be defined as:

\begin{center}
$\mathbf{LSU = L~||~d~||~L_{CE}}$
\end{center}


$p$ then computes its vote (or \textit{producer vote}):
\begin{center}
\fbox{$V = \mathcal{H}(LSU)~||~\#(\mathcal{L}(vote))~||~Id$}
\end{center}


\item $p$ then forwards their $V$ to the other producers and collects the producer votes $V$ issued by its peers.

\end{enumerate}


During the voting phase, the producer $p$ collects the producer votes $V$ broadcast by its peers. At the end of the voting phase , the producer $p$ holds $U$ producer votes $V$ in its cache. This will be equal to or less than the number of producers who formed the correct update. 
